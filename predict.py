# -*- coding: utf-8 -*-
"""predict.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ImsC0G4fODi-XQcjJAfmKoWPGz-qbFaS
"""

import argparse
import torch
from torch import nn
from torchvision import models
import numpy as np
from PIL import Image
import json

# Argument parsing
parser = argparse.ArgumentParser(description='Predict flower name from an image using a trained model')
parser.add_argument('image_path', type=str, help='Path to input image')
parser.add_argument('checkpoint', type=str, help='Path to checkpoint')
parser.add_argument('--top_k', type=int, default=5, help='Return top K most likely classes')
parser.add_argument('--category_names', type=str, help='Path to JSON file mapping categories to names')
parser.add_argument('--gpu', action='store_true', help='Use GPU for inference if available')
args = parser.parse_args()

# Function to load the checkpoint and rebuild the model
def load_checkpoint(filepath):
    checkpoint = torch.load(filepath)

    # Load the appropriate model architecture
    if checkpoint['arch'] == 'vgg16':
        model = models.vgg16(pretrained=True)
        model.classifier = checkpoint['classifier']
    elif checkpoint['arch'] == 'resnet18':
        model = models.resnet18(pretrained=True)
        model.fc = checkpoint['classifier']
    else:
        raise ValueError(f"Model architecture {checkpoint['arch']} is not supported.")

    # Load model state dict and class-to-index mapping
    model.load_state_dict(checkpoint['state_dict'])
    model.class_to_idx = checkpoint['class_to_idx']

    return model

# Function to process the input image for the model
def process_image(image_path):
    ''' Scales, crops, and normalizes a PIL image for a PyTorch model,
        returns a Numpy array. '''
    image = Image.open(image_path)

    # Resize the image where the shortest side is 256 pixels, keeping the aspect ratio
    if image.width > image.height:
        image = image.resize((256, int(256 * image.height / image.width)))
    else:
        image = image.resize((int(256 * image.width / image.height), 256))

    # Crop out the center 224x224 portion of the image
    left = (image.width - 224) / 2
    top = (image.height - 224) / 2
    right = left + 224
    bottom = top + 224
    image = image.crop((left, top, right, bottom))

    # Convert the image to a numpy array and normalize
    np_image = np.array(image) / 255
    mean = np.array([0.485, 0.456, 0.406])
    std = np.array([0.229, 0.224, 0.225])
    np_image = (np_image - mean) / std

    # Reorder dimensions so the color channel is first
    np_image = np_image.transpose((2, 0, 1))

    return np_image

# Function to make a prediction
def predict(image_path, model, topk=5):
    ''' Predict the class (or classes) of an image using a trained deep learning model. '''
    # Process the image
    image = process_image(image_path)
    image_tensor = torch.from_numpy(image).type(torch.FloatTensor).unsqueeze(0)

    # Move model and image to GPU if available and requested
    if args.gpu and torch.cuda.is_available():
        model.to('cuda')
        image_tensor = image_tensor.to('cuda')
    else:
        model.to('cpu')

    # Make prediction
    model.eval()
    with torch.no_grad():
        output = model.forward(image_tensor)
        probs, classes = torch.exp(output).topk(topk, dim=1)

    probs = probs.cpu().numpy().flatten()
    classes = classes.cpu().numpy().flatten()

    # Convert indices to actual class labels
    idx_to_class = {val: key for key, val in model.class_to_idx.items()}
    classes = [idx_to_class[i] for i in classes]

    return probs, classes

# Load category names from the JSON file, if provided
if args.category_names:
    with open(args.category_names, 'r') as f:
        cat_to_name = json.load(f)
else:
    cat_to_name = None

# Load the model from the checkpoint
model = load_checkpoint(args.checkpoint)

# Make prediction
probs, classes = predict(args.image_path, model, args.top_k)

# Map class indices to flower names, if category names are provided
if cat_to_name:
    flower_names = [cat_to_name[str(cls)] for cls in classes]
else:
    flower_names = classes

# Print the results
print(f"Probabilities: {probs}")
print(f"Flower names: {flower_names}")